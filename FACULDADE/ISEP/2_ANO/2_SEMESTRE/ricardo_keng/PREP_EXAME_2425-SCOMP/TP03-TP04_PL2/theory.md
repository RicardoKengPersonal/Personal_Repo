Signals
 A signal is a notification of an event sent to a specific process
▪ Process receives an integer that maps to a specific event
▪ They are a limited form of inter-process communication
 Notifications are asynchronous
▪ A process may receive a notification at any time, during its execution
 If you can’t predict when an event occurs, then it is not
practical to handle it in the main body of the program
▪ The solution is to write specialized code to handle the signal and execute it
only when necessary

Signal sources in a system
 Hardware interrupts
▪ Triggered by external hardware events
 Exceptions
▪ Generated by the CPU for errors such as invalid memory access or division
by zero
 User Input
▪ Special key combinations (e.g., CTRL+C)

Signal sources in a system
 User-raised signals
▪ Sent manually using commands like kill()
 Inter-process or OS signals
▪ Sent by other processes or the operating system
 Self-raised signals
▪ A process can send signals to itself using functions like raise() or
abort()

Interrupt handling
 CPU receives an interrupt
 Kernel takes over
▪ Saves current context
▪ Handles interrupt
▪ Restores saved context
 Interrupted process continues
executing

Signal handling
 Kernel receives a signal issued to
process
 Kernel saves current context
 Process handles signal by calling a
specific function
 Kernel restores saved context
 Signaled process continues
executing (or maybe terminates)

Some examples of signals
Signal Default action Description
SIGINT Terminate process Interrupt program
SIGILL Create core image Illegal instruction
SIGKILL Terminate process Kill program (can’t be ignored or handled)
SIGSEGV Create core image Segmentation violation (illegal memory access)
SIGALRM Terminate process Real-time timer expired
SIGSTOP Stop process Stop (can’t be ignored or handled)
SIGCONT Discard signal Continue after stop
SIGCHLD Discard signal Child status has changed
SIGUSR1 Terminate process User defined signal 1
SIGUSR2 Terminate process User defined signal 2

Dealing with an incoming signal
 Default action for a specific signal
▪ Terminate: SIGKILL, SIGINT, SIGUSR1, SIGUSR2
▪ Create core image and terminate: SIGILL, SIGSEGV, SIGFPE,
SIGABORT
▪ Stop/Continue: SIGSTOP, SIGCONT
▪ Ignore: SIGCHLD, SIGIO, SIGINFO
 Programmer-defined action (if signal allows)
▪ Ignore
▪ Execute a handler function

Signaling using the kill function

#include <signal.h>
int kill(pid_t pid, int sig);

 Sends the signal specified by sig to the process specified by
pid
▪ A non-root process cannot send signals to processes owned by other users
 If pid equals 0, then sig is sent to every process in the
process group of the calling process
 If pid equals -1, then sig is sent to every process for which
the calling process has permission to send signals

int main(){
 pid_t pid;
 pid = fork();
 if(pid > 0) {
 printf(“Hello child!\n”);
 sleep(5);
 printf("Goodbye child!\n");
 kill(pid, SIGUSR1);
 wait(NULL);
 }
 else {
 printf(“Child is running in an infinite loop…\n”);
 for(;;);
 }
}

Waiting for a signal
#include <signal.h>
int pause();

 Causes the calling process to pause until a signal is received
That either terminates the process or causes the invocation of a signalhandling function
 Upon termination of a signal handler started during a pause,
the pause() call will return

int main(){
 pid_t pid;
 pid = fork();
 if(pid > 0) {
 printf(“Hello child!\n”);
 sleep(5);
 printf("Goodbye child!\n");
 kill(pid, SIGUSR1);
 wait(NULL);
 }
 else {
 printf(“Child is running in an infinite loop…\n”);
 pause();
 }
}

Important note
 There is no signal buffering
▪ If a signal arrives before pause() is called, it is lost and will not wake up
the process
▪ pause() will not return until another signal arrives
 This can lead to synchronization issues if pause() is used
without ensuring the signal is sent at the right moment

Signaling using the raise function

#include <signal.h>
int raise(int sig);

 Sends the signal specified by sig to the calling process
▪ It is equivalent to kill(getpid(), sig)
 If the signal causes a handler to be called, raise() will return
only after the signal handler has returned

Signaling using the alarm function

#include <signal.h>
unsigned int alarm(unsigned int seconds);

 Sends the SIGALRM signal to the current process in seconds
seconds
▪ If seconds is zero, any pending alarm is canceled
 Alarms created by alarm() are preserved across exec() and
are not inherited by children created via fork()

Setting the action for a signal

#include <signal.h>
int sigaction(int sig,
 const struct sigaction *act,
 struct sigaction *oact);

  Modifies the behavior of a process when receiving a specific
signal sig
▪ act specifies the action details for the signal sig
▪ oact (if not NULL) stores the previously set action details
 Let’s explore struct sigaction
▪ A powerful mechanism for defining how a process responds to signals,
allowing custom handlers, signal masks, and fine-grained control over
signal behavior

struct sigaction
 May differ slightly across architectures but these fields must
comply with POSIX
▪ sa_handler
▪ Pointer to an ANSI C handler function
▪ sa_sigaction
▪ Pointer to a POSIX handler function (next class)
▪ sa_mask
▪ This specifies a set of signals to be blocked while the handler runs (next
class)
▪ sa_flags
▪ This specifies various flags which can affect the behavior of the signal

The sa_flags field
 The sa_flags field determines several different things, but
the important ones are:
▪ Whether we get the extended information (SA_SIGINFO)
▪ Whether system calls that were interrupted by the signal are automatically
restarted (SA_RESTART)
▪ The alternative is that the interrupted system calls will fail, so restarting
them is obviously a better approach
 Each signal number has its own set of flags
▪ Check out the manual pages

Defining signal handlers
 A signal handler is just a function that you compile together
with the rest of the program
▪ Instead of directly invoking the function, you use sigaction() to tell
the OS to call it when a signal arrives
 You need to take special care in writing handler functions
because they can be called asynchronously
▪ That is, a handler might be called at any point in the program,
unpredictably
▪ If two signals arrive during a very short interval, one handler can run within
another
▪ (more on this in the next class)

The sa_handler field
 Used to set an ANSI C handler function
▪ Minimal control over the behavior of signals during their handling
 Possible values:
▪ SIG_DFL for the default action
▪ SIG_IGN to ignore the signal
▪ Recall that SIGKILL and SIGSTOP cannot be ignored!
▪ void (*sa_handler)(int)
▪ Pointer to an ANSI C signal handler function that is executed upon signal
reception
▪ This function receives the signal number as its only argument

/* (...) */
int main(int argc, char *argv[]){
 struct sigaction act;
 /* Zeroes the sigaction structure */
 memset(&act, 0, sizeof(struct sigaction));
 act.sa_handler = SIG_IGN;
 sigaction(SIGUSR1, &act, NULL);
 /* SIGUSR1 will now be ignored. */
 /* (...) */
}

## Example – capturing SIGUSR1


void handle_USR1(int signo){
 write(STDOUT_FILENO, “\nCatch USR1!\n”, 13);
}
int main(int argc, char *argv[]){
 struct sigaction act;
 /* Zeroes the sigaction structure */
 memset(&act, 0, sizeof(struct sigaction));

 act.sa_handler = handle_USR1;
 act.sa_flags = SA_RESTART;
 sigaction(SIGUSR1, &act, NULL);
 /* SIGUSR1 will now be captured and handled (ANSI C) */
 /* (...) */
}

void handle_ALARM(int signo){
write(STDOUT_FILENO, “\nTime for a coffee!\n”, 20);
}
int main(){
struct sigaction act;
 /* Zeroes the sigaction structure */
memset(&act, 0, sizeof(struct sigaction));
 act.sa_handler = handle_ALARM;
 act.sa_flags = SA_RESTART;
sigaction(SIGALRM, &act, NULL);
/* SIGALRM is now set to be catch and handled */
alarm(10);
/* You have 10 seconds before interrupting the following code for a coffee */
do_some_very_long_task();
}

## TP04 (part 2)

Safe signal handling
 Handlers are tricky because they are concurrent with main
program and share the same global data structures
▪ Shared data structures can become corrupted
▪ We’ll explore concurrency issues later in the semester
 Keep your handlers as simple as possible
 Call only async-signal-safe functions in your handlers
▪ printf, sprintf, malloc, and exit are not safe!
▪ Run man signal-safety in command line to view a list of signal-safe
functions

Safe signal handling
 Protect accesses to shared data structures by temporarily
blocking all signals to prevent possible corruption
 Declare global variables as volatile to prevent the compiler
from storing them in a register
▪ The compiler may optimize away reads and writes to non-volatile
variables, assuming they don't change outside of normal program flow
 Declare global flags as volatile sig_atomic_t
▪ sig_atomic_t is an integer type guaranteed to be read and written
atomically
▪ Use only in a variable that is only read or written (e.g., flag = 1, not
flag++)

Setting the action for a signal

#include <signal.h>
int sigaction(int sig,
 const struct sigaction *act,
 struct sigaction *oact);

 Modifies the behavior of a process when receiving a specific
signal sig
▪ act specifies the action details for the signal sig
▪ oact (if not NULL) stores the previously set action details

struct sigaction
 May differ slightly across architectures but these fields must
comply with POSIX
▪ sa_handler
▪ Pointer to an ANSI C handler function (previous
class)
▪ sa_sigaction
▪ Pointer to a POSIX handler function (this class)
▪ sa_mask
▪ This specifies a set of signals to be blocked while the handler runs (this
class)
▪ sa_flags
▪ This specifies various flags which can affect the behavior of the signal
(previous class)

The sa_sigaction field
 Used to set a POSIX-compliant signal handler
▪ Provides more flexibility and control over the signal handling process
▪ Requires the SA_SIGINFO flag to be set in the sa_flags field to enable
extended information passing to the handler
 Cannot be used simultaneously with an ANSI C signal handler,
as they are mutually exclusive
 Possible values:
▪ A pointer to a POSIX signal handler function that is executed upon signal
reception

The sa_sigaction field
 void (*sa_sigaction)(int sig, siginfo_t
*info, void *ucontext)
▪ sig
▪ The number of the signal that caused the invocation of the handler
▪ info
▪ A pointer to a siginfo_t structure containing further information
about the signal
▪ ucontext
▪ A pointer to a ucontext_t structure, cast to void *, containing
signal context information that was saved on the user-space stack by
the kernel

void handle_USR1(int signo, siginfo_t *sinfo, void *context){
 /* Don’t use printf: it’s not safe!!! See man signal-safety for a list of safe functions */
 printf("Signal %d sent by process %d\n",
 sinfo->si_signo, sinfo->si_pid);
}
int main(int argc, char *argv[]){
 struct sigaction act;

 /* Zeroes the sigaction structure */
 memset(&act, 0, sizeof(struct sigaction));

 act.sa_sigaction = handle_USR1;
 act.sa_flags = SA_SIGINFO;
 sigaction(SIGUSR1, &act, NULL);
 /* SIGUSR1 will now be captured and handled (POSIX) */
 /* (...) */
} 

More advanced signal handling
 Multiple signal reception
▪ Understand the behavior when multiple signals arrive while a handler is
being executed
 Blocking signals
▪ Temporarily preventing specific signals from being delivered

Multiple signal reception
 When a signal is being handled, subsequent notifications of the
same signal number are automatically blocked
▪ For each signal type, one bit in the kernel indicates whether a signal is
pending, thus at most one pending signal of any type
▪ Once the handler returns, if the bit is still set, the kernel will deliver the
signal again, but it does not distinguish how many times the signal arrived
in the meantime
 Therefore, you can’t use signals to count events!
▪ Such as children terminating
 But what about other signals?
▪ By default, they will interrupt the current handler to trigger their own
handler

Nested signal handlers
 Handlers can be interrupted by other handlers
▪ Adds complexity to signal handling logic to avoid issues such as race
conditions or deadlocks


Multiple signal reception
 The sa_mask field of struct sigaction is used to specify
which additional signals should be blocked during the
execution of the signal handling function
▪ Not allowing an incoming signal to interrupt the signal handling
 Recall that a blocked signal is not ignored!
▪ The signal is delayed until it becomes unblocked, i.e., when the handler
completes
 Signal blocking is implemented using a sigset_t data type
▪ The set of blocked signals is then manipulated using functions such as
sigaddset, sigdelset, etc. (collectively referred to as sigset
operations)

## Example – adding signals to the set

void handle_USR1(int signo, siginfo_t *sinfo, void *context){
 …
}
int main(int argc, char *argv[]){
 struct sigaction act;
 memset(&act, 0, sizeof(struct sigaction));

 sigemptyset(&act.sa_mask); /* No signals blocked */
 sigaddset(&act.sa_mask, SIGINT); /* Block SIGINT */
 sigaddset(&act.sa_mask, SIGUSR2); /* Block SIGUSR2 */
 act.sa_sigaction = handle_USR1;
 act.sa_flags = SA_SIGINFO;
 sigaction(SIGUSR1, &act, NULL);
 /* Now, when a SIGUSR1 is received, SIGINT and SIGUSR2 are blocked
 during the execution of handle_USR1 */
 /* (...) */
}

## Example – removing signals from the set


void handle_USR2(int signo, siginfo_t *sinfo, void *context){
 …
}
int main(int argc, char *argv[]){
 struct sigaction act;
 memset(&act, 0, sizeof(struct sigaction));

 sigfillset(&act.sa_mask); /* All signals blocked */
sigdelset(&act.sa_mask, SIGCHLD); /* Unblock SIGCHLD */
sigdelset(&act.sa_mask, SIGUSR1); /* Unblock SIGUSR1 */
act.sa_sigaction = handle_USR2;
act.sa_flags = SA_SIGINFO;
sigaction(SIGUSR2, &act, NULL);
/* Now, when a SIGUSR2 is received, all signals except SIGCHLD and SIGUSR1 are blocked
 during the execution of handle_USR2 */
 /* (...) */
}

Blocking/unblocking signals
 Blocking signals and preventing interrupts to signal handlers
are related but distinct concepts
 Blocking a signal means the OS is instructed to hold onto the
signal and not deliver it to the process immediately
▪ The signal remains pending
▪ Think of it like putting a message in a queue for later delivery
 Primarily used to prevent a signal from interrupting a sensitive
section of code
▪ This ensures that critical operations (like updating shared data structures)
can complete without being disrupted

The sigprocmask function

#include <signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);

 Used to fetch and/or change the signal mask of the calling
process
▪ The signal mask is the set of signals whose delivery is currently blocked for
the caller
 The behavior of the call is dependent on the value of how
▪ SIG_BLOCK: The set of blocked signals is the union of the current set and
the set argument
▪ SIG_UNBLOCK: The signals in set are removed from the current set of
blocked signals
▪ SIG_SETMASK: The set of blocked signals is set to the argument set

The sigpending function
#include <signal.h>
int sigpending(sigset_t *set);

Fetch the set of signals that are pending for delivery to the
calling process
▪ (i.e., the signals which have been raised while blocked)
▪ The mask of pending signals is returned in set

Important note
 When created, a child process inherits the signal mask (set of
blocked signals) and signal disposition (e.g., default or ignored
signals) of the parent process
 However, any custom signal handlers set with sigaction()
in the parent are reset to their default behavior in the child
 Therefore, the child must explicitly set up its own signal
handlers if needed

## Example – blocking/unblocking signals


int main(){
 sigset_t mask, pending;
 sigemptyset(&mask);
 sigaddset(&mask,SIGINT);
 sigprocmask(SIG_BLOCK, &mask, 0);
 /* CTRL-C is now blocked! */
 sleep(10);
 /* Check if SIGINT is pending... */
 sigpending(&pending);
 if(sigismember(&pending, SIGINT))
 printf("User tried to interrupt the sleep function\n");
 sigprocmask(SIG_UNBLOCK, &mask, 0);
 /* CTRL-C is now unblocked! */
 /* (...) */
}

Example 2 – blocking/unblocking signals
 Assume a signal handler sets a sig_atomic_t flag, and you
need to check the flag before performing an action
 If the signal is delivered right after you check the flag but
before the action, it can cause unexpected behavior
▪ An example of the check-then-act race condition
 To ensure reliable testing, check the flag while the signal is
blocked

volatile sig_atomic_t flag = 0;
void handle_signal(int signum){
 flag = 1;
}
int main() {
 struct sigaction sa;
 sigset_t block_mask, old_mask;
 sa.sa_handler = handle_signal;
 sa.sa_flags = SA_RESTART;
 sigemptyset(&sa.sa_mask);
 /* No signals are blocked during handler execution */
 /* Register the signal handler for SIGUSR1 */
 sigaction(SIGUSR1, &sa, NULL);

sigemptyset(&block_mask);
 sigaddset(&block_mask, SIGUSR1);
 while (1) {
 /* Block the signal */
 sigprocmask(SIG_BLOCK, &block_mask, &old_mask);
 /* Check the flag while the signal is blocked */
 if(flag) {
 perform_action();
 flag = 0;
 }
 /* Unblock the signal (so it can be delivered if it's pending) */
 sigprocmask(SIG_SETMASK, &old_mask, NULL);

 sleep(5);
 }
 return 0;
}

